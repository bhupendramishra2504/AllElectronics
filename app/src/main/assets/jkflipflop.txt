library ieee;
use ieee.std_logic_1164.all;

----------------------------------------------

entity JK_FF is
port (	clock:		in std_logic;
	J, K:		in std_logic;
	reset:		in std_logic;
	Q, Qbar:	out std_logic
);
end JK_FF;

-----------------------------------------------

architecture behv of JK_FF is

    -- define the useful signals here

    signal state: std_logic;
    signal input: std_logic_vector(1 downto 0);

begin

    -- combine inputs into vector
    input <= J & K;		

    p: process(clock, reset) is
    begin
	
	if (reset='1') then
	    state <= '0';
	elsif (rising_edge(clock)) then

            -- compare to the truth table
	    case (input) is
		when "11" =>
		    state <= not state;
		when "10" =>
		    state <= '1';
		when "01" =>
		    state <= '0';
		when others =>
		    null;
		end case;
	end if;

    end process;
	
    -- concurrent statements
    Q <= state;
    Qbar <= not state;

end behv;



TEST BENCH

library ieee;
use ieee.std_logic_1164.all;

entity jkff_TB is			-- entity declaration
end jkff_TB;

---------------------------------------------------------------------

architecture TB of jkff_TB is

    signal T_J, T_K: 	std_logic;
    signal T_clock:	std_logic;
    signal T_reset:	std_logic;
    signal T_Q, T_Qbar:	std_logic;
	
    component JK_FF is
    port (	clock:		in std_logic;
		J, K:		in std_logic;
		reset:		in std_logic;
		Q, Qbar:	out std_logic
    );
    end component;
		
begin

    U_JKFF: JK_FF port map (T_clock, T_J, T_K, T_reset, T_Q, T_Qbar);

    -- concurrent process to offer clock signal	
    process
    begin
	T_clock <= '0';
	wait for 5 ns;
	T_clock <= '1';
	wait for 5 ns;
    end process;
	
    process

	variable err_cnt: integer := 0;

    begin
		
    	T_reset <= '1';
	wait for 25 ns;

	T_reset <= '0';
	wait for 10 ns;

	-- case 1
	T_J <= '0';
	T_K <= '1';
	wait for 15 ns;
	assert (T_Q='0') report "Error1!" severity error; 
	if (T_Q/='0') then
	    err_cnt := err_cnt + 1;
	end if;

	-- case 2
	wait for 5 ns;
	T_J <= '1';
	T_K <= '0';
	wait for 15 ns;
	assert (T_Q='1') report "Error2!" severity error; 
	if (T_Q/='0') then
	    err_cnt := err_cnt + 1;
	end if;

	-- case 3
	wait for 5 ns;
	T_J <= '1';
	T_K <= '1';
	wait for 15 ns;
	assert (T_Q='0') report "Error3!" severity error;
	if (T_Q/='0') then
	    err_cnt := err_cnt + 1;
	end if;
		
	-- summary of all the tests
	if (err_cnt=0) then 			
	    assert false 
	    report "Testbench of Adder completed successfully!" 
	    severity note; 
	else 
	    assert true 
	    report "Something wrong, try again" 
	    severity error; 
	end if; 

 	wait;

    end process;

end TB;

--------------------------------------------------------------------
configuration CFG_TB of jkff_TB is
	for TB
	end for;
end CFG_TB;


GATE LEVEL IMPLEMENTATION

library IEEE,lsi_10k;

use IEEE.std_logic_1164.all;
use IEEE.std_logic_arith.all;
use IEEE.std_logic_textio.all;
use lsi_10k.COMPONENTS.all;

package CONV_PACK_counter is

-- define attributes
attribute ENUM_ENCODING : STRING;

end CONV_PACK_counter;

library IEEE,lsi_10k;

use IEEE.std_logic_1164.all;
use IEEE.std_logic_arith.all;
use IEEE.std_logic_textio.all;
use lsi_10k.COMPONENTS.all;

use work.CONV_PACK_counter.all;

entity counter is

   generic( n : Integer := 2);
   port( clock, clear, count : in std_logic;  Q : out std_logic_vector (1 
         downto 0));

end counter;

architecture SYN of counter is

   component IV
      port( A : in std_logic;  Z : out std_logic);
   end component;
   
   component EO
      port( A, B : in std_logic;  Z : out std_logic);
   end component;
   
   component ND2
      port( A, B : in std_logic;  Z : out std_logic);
   end component;
   
   component FD2
      port( D, CP, CD : in std_logic;  Q, QN : out std_logic);
   end component;
   
   signal Q_1_port, Q_0_port, n149, n150, net9, n151, n152, n153 : std_logic;

begin
   Q <= ( Q_1_port, Q_0_port );
   
   U31 : IV port map( A => clear, Z => n150);
   U32 : EO port map( A => Q_0_port, B => count, Z => n152);
   U33 : EO port map( A => n149, B => net9, Z => n151);
   U34 : ND2 port map( A => count, B => Q_0_port, Z => n149);
   Pre_Q_regx1x : FD2 port map( D => n151, CP => clock, CD => n150, Q => 
                           Q_1_port, QN => net9);
   Pre_Q_regx0x : FD2 port map( D => n152, CP => clock, CD => n150, Q => 
                           Q_0_port, QN => n153);

end SYN;
